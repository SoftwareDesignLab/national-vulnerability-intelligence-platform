/**
 * Copyright 2023 Rochester Institute of Technology (RIT). Developed with
 * government support under contract 70RSAT19CB0000020 awarded by the United
 * States Department of Homeland Security.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package servlet;

import java.io.IOException;
import java.time.LocalDate;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONArray;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

import dao.LocalDateSerializer;
import dao.VulnerabilityDAO;
import model.Vulnerability;

@WebServlet("/vulnerabilityServlet")
public class VulnerabilityServlet extends HttpServlet {
	private static final Logger logger = LogManager.getLogger(VulnerabilityServlet.class);

	private static final long serialVersionUID = 1L;

	private JsonArray toJsonArray(Gson gson, Collection c, Class clazz) {
		JsonElement element = gson.toJsonTree(c, clazz);
		if (!element.isJsonArray()) {
			return null;
		}

		return element.getAsJsonArray();
	}

	@Override
	public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException {
		handleRequest(req, resp);
	}

	public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException {

		/*
		 * TODO: Bring back user info params for user recommended CVEs String userName =
		 * req.getParameter("username"); String token = req.getParameter("token");
		 * 
		 * if (userName == null || token == null) { System.out.println("Issues");
		 * ServletUtil.setResponse(resp, 401, "Unauthorized user!"); }
		 * 
		 * User user = UserDAO.getRoleIDandExpirationDate(userName, token);
		 * 
		 * if (user == null) ServletUtil.setResponse(resp, 401, "Unauthorized user!");
		 */

		int vulnId = req.getParameter("vulnId") == null ? 0 : Integer.parseInt(req.getParameter("vulnId"));
		boolean daily = req.getParameter("daily") == null ? false : Boolean.parseBoolean(req.getParameter("daily"));
		String match = req.getParameter("match") == null ? "" : req.getParameter("match");

		JSONArray arrayObj = null;
		JsonObject dailyVulnsJson = new JsonObject();
		JsonObject allVunsJson = new JsonObject();

		GsonBuilder gsonBuilder = new GsonBuilder();
		gsonBuilder.registerTypeAdapter(LocalDate.class, new LocalDateSerializer());
		Gson gson = gsonBuilder.setPrettyPrinting().create();

		try {
			if (vulnId != 0) {
				Vulnerability vuln = VulnerabilityDAO.getVulnerability(vulnId);
				String jObj = gson.toJson(vuln);

				resp.setContentType("text/html");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(jObj);
			} else if (daily) {
				int dateRange = req.getParameter("dateRange") == null ? 0
						: Integer.parseInt(req.getParameter("dateRange"));
				Map<LocalDate, List<Vulnerability>> dailyVulns = VulnerabilityDAO.getDailyVulnerabilities(dateRange);

				removeLowQualityCves(dailyVulns);

				int i = 0;
				for (LocalDate date : dailyVulns.keySet().stream().sorted((e1, e2) -> e2.compareTo(e1))
						.collect(Collectors.toList())) {
					dailyVulnsJson = new JsonObject();

					dailyVulnsJson.add("date", gson.toJsonTree(date, LocalDate.class));
					dailyVulnsJson.add("list", toJsonArray(gson, dailyVulns.get(date), List.class));

					allVunsJson.add(i + "", gson.toJsonTree(dailyVulnsJson));
					i++;
				}

				String testObj = gson.toJson(allVunsJson);
				resp.setContentType("text/html");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(testObj);
			} else if (match != "") {
				logger.debug("Match hit: {}", match);
				List vulns = VulnerabilityDAO.getVulnerabilityByMatch(match);

				arrayObj = null;
				String jObj = new Gson().toJson(arrayObj);

				resp.setContentType("text/html");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(jObj);
			}

		} catch (IOException ex) {
			logger.error(ex.toString());
		}
	}

	private void removeLowQualityCves(Map<LocalDate, List<Vulnerability>> dailyVulns) {
		String pattern = "\\bCVE-20\\d{2}-\\d{4,5}\\b";

		Pattern p = Pattern.compile(pattern);
		Matcher m;

		int patternLength = 0;

		for (LocalDate date : dailyVulns.keySet()) {
			List<Vulnerability> vulns = dailyVulns.get(date);
			for (int i = 0; i < vulns.size(); i++) {
				m = p.matcher(vulns.get(i).getDescription());
				while (m.find())
					patternLength += m.group().length();

				if (patternLength >= vulns.get(i).getDescription().length() * 0.9) {
					vulns.remove(i);
					i--; // Decrement so on same position in list
				}

				patternLength = 0;
			}
		}
	}
}