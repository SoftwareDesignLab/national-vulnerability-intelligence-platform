/**
 * Copyright 2021 Rochester Institute of Technology (RIT). Developed with
 * government support under contract 70RSAT19CB0000020 awarded by the United
 * States Department of Homeland Security.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the �Software�), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED �AS IS�, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package dao;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import data.DBConnect;
import model.CvssScore;
import model.Product;
import model.VdoCharacteristic;
import model.Vulnerability;
import servlet.VulnerabilityServlet;
import util.VulnerabilityUtil;

public class VulnerabilityDAO {
	private static String dbType = DBConnect.getDatabaseType();
	private static final Logger logger = LogManager.getLogger(VulnerabilityDAO.class);

	/*
	private Timestamp fixedDate = null;
	private String[] sources = {};
	private VdoCharacteristic[] vdoList = {};
	private CvssScore[] cvssScoreList = null;
	private Product[] products = null;
	*/
	
	
	/**
	 * Calls a SP that returns a single vulnerability indentified by a single
	 * vulnerability id
	 * 
	 * @param vulnId Vulnerability id that is used to retrieve the vulnerability
	 * @return A single vulnerability entity
	 */
	public static Vulnerability getVulnerability(int vulnId) {
		String query = "SELECT v.vuln_id, v.cve_id, v.description, v.platform, v.published_date, v.last_modified_date,"
				+ " MAX(pc.commit_date) AS fixed_date, pc.commit_url, pc.commit_date, v.exists_at_nvd, v.exists_at_mitre, v.vdo_labels, "
				+ " v.vdo_label_confidences, v.vdo_noun_groups, v.urls, v.base_severities, v.severity_confidences, "
				+ " v.impact_scores, v.impact_confidences, v.product_id, v.cpe, v.domain, v.version, "
				+ " v.exploit_publish_date, v.exploit_url, ps.source_url "
				+ " FROM vulnerabilityaggregate v "
				+ " LEFT JOIN patchsourceurl ps ON v.vuln_id = ps.vuln_id "
				+ " LEFT JOIN patchcommit pc ON ps.source_url_id = pc.source_id "
				+ " WHERE v.vuln_id = ?"
				+ " GROUP BY v.cve_id, v.description, v.platform, v.published_date, v.last_modified_date, fixed_date, "
				+ " pc.commit_url, pc.commit_date, v.exists_at_nvd, v.exists_at_mitre, v.vdo_labels,  v.vdo_label_confidences,"
				+ " v.vdo_noun_groups, v.urls, v.base_severities, v.severity_confidences,  v.impact_scores, v.impact_confidences, v.product_id, v.cpe,"
				+ " v.domain, v.version,  v.exploit_publish_date, v.exploit_url, ps.source_url"
				+ " ORDER BY pc.commit_date DESC "
				+ " LIMIT 1";

		System.out.println(query);

		// no data from the aggregate table(summary), get CVE from the main
		// vulnerability table
		try (Connection conn = DBConnect.getConnection(); PreparedStatement stmt = conn.prepareStatement(query);) {

			stmt.setInt(1, vulnId);
			ResultSet rs = stmt.executeQuery();
			Vulnerability vuln = null;
			Timestamp fixedDate = null;
			String[] sources = {};
			VdoCharacteristic[] vdoList = {};
			CvssScore[] cvssScoreList = null;
			//Product product = null;
			Product[] products = null;
			boolean urlsCheck = true;

			if (!rs.next()) {
				// no data from the aggregate table(summary), get CVE from the main
				// vulnerability table
				
				query = "Select v.vuln_id, v.cve_id, v.description, v.platform, v.published_date, v.exists_at_mitre, v.exists_at_nvd, v.last_modified_date,"
						+ " MAX(pc.commit_date) AS fixed_date, pc.commit_url, ar.version, p.product_id, p.cpe, p.domain, group_concat(vc.vdo_confidence SEPARATOR ';') AS vdo_label_confidences, "
						+ " group_concat(vl.vdo_label_name SEPARATOR ';') AS vdo_labels, group_concat(vn.vdo_noun_group_name SEPARATOR ';') AS vdo_noun_groups,"
						+ " cvsever.cvss_severity_class as base_severities, cvscore.severity_confidence AS severity_confidences, "
						+ " cvscore.impact_score AS impact_scores, cvscore.impact_confidence AS impact_confidences, group_concat(vc.vdo_label_id SEPARATOR ';') AS label_ids, "
						+ " ex.publisher_url AS exploit_url, ex.publish_date AS exploit_publish_date, ps.source_url"
						+ " FROM vulnerability v"
						+ " LEFT JOIN affectedrelease ar ON ar.cve_id = v.cve_id"
						+ " LEFT JOIN product p ON p.product_id = ar.product_id"
						+ " LEFT JOIN exploit ex ON ex.vuln_id = v.vuln_id"
						+ " LEFT JOIN vdocharacteristic vc ON vc.cve_id = v.cve_id"
						+ " LEFT JOIN vdolabel vl ON vl.vdo_label_id = vc.vdo_label_id"
						+ " LEFT JOIN vdonoungroup vn ON vn.vdo_noun_group_id = vl.vdo_noun_group_id"
						+ " LEFT JOIN cvssscore cvscore ON cvscore.cve_id = v.cve_id"
						+ " LEFT JOIN cvssseverity cvsever ON cvsever.cvss_severity_id = cvscore.cvss_severity_id "
						+ " LEFT JOIN patchsourceurl ps ON v.vuln_id = ps.vuln_id "
						+ " LEFT JOIN patchcommit pc ON ps.source_url_id = pc.source_id "
						+ " WHERE v.vuln_id = ?"
						+ " GROUP BY v.cve_id, v.description, v.platform, v.published_date, v.last_modified_date, fixed_date, ar.version,"
						+ " pc.commit_url, pc.commit_date, v.exists_at_nvd, v.exists_at_mitre, p.product_id, cvsever.cvss_severity_class, cvscore.severity_confidence,"
						+ " cvscore.impact_score, cvscore.impact_confidence, ex.publisher_url, ex.publish_date, ps.source_url"
						+ " ORDER BY pc.commit_date DESC"
						+ " LIMIT 1;";

				CallableStatement stmt2 = conn.prepareCall(query);
				urlsCheck = false;
				stmt2.setInt(1, vulnId);
				System.out.print(stmt2);
				rs = stmt2.executeQuery();
				rs.next();
			}
			
			//Checks if the vulnerability data was pulled from vulnerabilityaggregate, if so, get the urls
			if (urlsCheck) {
				sources = VulnerabilityUtil.parseArray(rs.getString("urls"));
			}
			fixedDate = rs.getTimestamp("fixed_date");
			vdoList = VulnerabilityUtil.parseVDOList(rs.getString("cve_id"), rs.getString("vdo_labels"), rs.getString("vdo_label_confidences"), rs.getString("vdo_noun_groups"));
			cvssScoreList = VulnerabilityUtil.parseCvssScoreList(rs.getString("cve_id"), rs.getString("base_severities"), rs.getString("severity_confidences"), rs.getString("impact_scores"),
					rs.getString("impact_confidences"));

			products = VulnerabilityUtil.parseProductList(rs.getString("product_id"), rs.getString("cpe"), rs.getString("domain"), rs.getString("version"));
			// product = new Product(rs.getInt("product_id"), rs.getString("cpe"),
			// rs.getString("domain"), null, rs.getString("version"));
			
			String exploitPublishDate =  rs.getString("exploit_publish_date")!=null?rs.getString("exploit_publish_date"):"NA";
			String exploitUrl = rs.getString("exploit_url")!=null?rs.getString("exploit_url"):"NA";

			vuln = new Vulnerability(rs.getInt("vuln_id"), rs.getString("cve_id"), rs.getString("description"), rs.getString("platform"), rs.getString("published_date"),
					rs.getString("last_modified_date"), (fixedDate == null ? null : fixedDate.toLocalDateTime()), rs.getBoolean("exists_at_mitre"), rs.getBoolean("exists_at_nvd"), sources,
					vdoList, cvssScoreList, products, exploitPublishDate, exploitUrl);
			vuln.setPatch(rs.getString("commit_url"));
			return vuln;

		} catch (SQLException e) {
			logger.error(e.getMessage());
		}

		return null;
	}

	public static List<Vulnerability> getVulnerabilityByMatch(String match) {
		try (Connection conn = DBConnect.getConnection()) {
			List<Vulnerability> vulns = new ArrayList<Vulnerability>();
			PreparedStatement stmt = conn
					.prepareStatement("SELECT v.vuln_id, v.cve_id, v.description, v.platform, v.published_date, v.last_modified " + "FROM vulnerability v WHERE v.description LIKE ?");
			stmt.setString(1, "%" + match + "%");

			ResultSet rs = stmt.executeQuery();

			while (rs.next()) {
				vulns.add(new Vulnerability(rs.getInt("vuln_id"), rs.getString("cve_id"), rs.getString("description"), rs.getString("platform"), rs.getString("published_date"),
						rs.getString("last_modified")));
			}

			return vulns;
		} catch (SQLException e) {
			logger.error(e.getMessage());
		}

		return null;
	}

	/**
	 * Retrieves the vulnerabilities that have been updated within a given number of
	 * days from the current date.
	 * 
	 * @param dateRange Number of days before the current date that vulnerabilities
	 *                  will be gathered from
	 * @return Map of vulnerabilities mapped by the date associated with the when
	 *         the vulnerability was updated and the list of vulnerabilities that
	 *         were updated at that date
	 */
	public static Map<LocalDate, List<Vulnerability>> getDailyVulnerabilities(int dateRange) {

		String query = "select * from vulnerabilityaggregate WHERE run_date_time BETWEEN ? AND ? ORDER BY exists_at_nvd ASC;";
		try (Connection conn = DBConnect.getConnection(); PreparedStatement stmt = conn.prepareStatement(query);) {
			// Get the CVEs for the last 3 days from 2 days ago to today (inclusive)
			LocalDateTime today = LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT).plusDays(1);

			stmt.setTimestamp(1, Timestamp.valueOf(today.minusDays(dateRange)));
			stmt.setTimestamp(2, Timestamp.valueOf(today));

			Timestamp fixedDate = null;
			String[] sources = {};
			VdoCharacteristic[] vdoList = {};
			CvssScore[] cvssScoreList = null;
			Map<LocalDate, List<Vulnerability>> dailyVulns = new LinkedHashMap<>();
			//Product product = null;
			Product[] products = null;

			// Populate the dailyVulns map with an empty list of vulns for each day of the
			// search
			for (int days = dateRange; days > 0; days--)
				dailyVulns.put(today.minusDays(days).toLocalDate(), new ArrayList<>());

			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				try {
					if (dailyVulns.get(rs.getTimestamp("run_date_time").toLocalDateTime().toLocalDate()) == null)
						continue;

					fixedDate = rs.getTimestamp("fixed_date");
					vdoList = VulnerabilityUtil.parseVDOList(rs.getString("cve_id"), rs.getString("vdo_labels"), rs.getString("vdo_label_confidences"), rs.getString("vdo_noun_groups"));
					cvssScoreList = VulnerabilityUtil.parseCvssScoreList(rs.getString("cve_id"), rs.getString("base_severities"), rs.getString("severity_confidences"), rs.getString("impact_scores"),
							rs.getString("impact_confidences"));

					products = VulnerabilityUtil.parseProductList(rs.getString("product_id"), rs.getString("cpe"), rs.getString("domain"), rs.getString("version"));
					// product = new Product(rs.getInt("product_id"), rs.getString("cpe"),
					// rs.getString("domain"), null, rs.getString("version"));

					dailyVulns.get(rs.getTimestamp("run_date_time").toLocalDateTime().toLocalDate())
							.add(new Vulnerability(rs.getInt("vuln_id"), rs.getString("cve_id"), rs.getString("description"), rs.getString("platform"), rs.getString("published_date"),
									rs.getString("last_modified_date"), (fixedDate == null ? null : fixedDate.toLocalDateTime()), rs.getBoolean("exists_at_mitre"), rs.getBoolean("exists_at_nvd"),
									sources, vdoList, cvssScoreList, products));
				} catch (Exception e) {
					e.printStackTrace();
					logger.error(e.getMessage());
				}
			}
			return dailyVulns;
		} catch (SQLException e) {
			logger.error(e.getMessage());
		}

		return null;
	}

	public static void main(String[] args) {

	}
}