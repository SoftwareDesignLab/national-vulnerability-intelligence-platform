package nvip_site.dao;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import nvip_site.model.CvssScore;
import nvip_site.dao.util.VulnerabilityUtil;
import nvip_site.data.DBConnect;
import nvip_site.model.Product;
import nvip_site.model.VdoCharacteristic;
import nvip_site.model.Vulnerability;
import nvip_site.servlet.VulnerabilityServlet;

public class VulnerabilityDAO {
	private static String dbType = DBConnect.getDatabaseType();
	private static final Logger logger = LogManager.getLogger(VulnerabilityDAO.class);

	/**
	 * Calls a SP that returns a single vulnerability indentified by a single
	 * vulnerability id
	 * 
	 * @param vulnId Vulnerability id that is used to retrieve the vulnerability
	 * @return A single vulnerability entity
	 */
	public static Vulnerability getVulnerability(int vulnId) {
		String query = "SELECT v.vuln_id, v.cve_id, description, platform, published_date, last_modified_date, fixed_date, exists_at_nvd, exists_at_mitre, vdo_labels, vdo_label_confidences, vdo_noun_groups, urls, base_severities, severity_confidences, impact_scores, impact_confidences, product_id, cpe, domain, version "
				+ "FROM vulnerabilityaggregate v " + "WHERE v.vuln_id = ?;";
		try (Connection conn = DBConnect.getConnection(); PreparedStatement stmt = conn.prepareStatement(query);) {

			stmt.setInt(1, vulnId);

			ResultSet rs = stmt.executeQuery();
			Vulnerability vuln = null;
			Timestamp fixedDate = null;
			String[] sources = {};
			VdoCharacteristic[] vdoList = {};
			CvssScore[] cvssScoreList = null;
			Product product = null;
			Product[] products = null;

			while (rs.next()) {
				sources = VulnerabilityUtil.parseArray(rs.getString("urls"), ";", new String[0]);
				vdoList = VulnerabilityUtil.parseVDOList(rs.getString("cve_id"), rs.getString("vdo_labels"), rs.getString("vdo_label_confidences"), rs.getString("vdo_noun_groups"), ";", null);
				cvssScoreList = VulnerabilityUtil.parseCvssScoreList(rs.getString("cve_id"), rs.getString("base_severities"), rs.getString("severity_confidences"), rs.getString("impact_scores"), rs.getString("impact_confidences"), ";",
						null);
				
				products = VulnerabilityUtil.parseProductList(rs.getString("product_id"), rs.getString("cpe"), rs.getString("domain"), rs.getString("version"), ";", null);
				//product = new Product(rs.getInt("product_id"), rs.getString("cpe"), rs.getString("domain"), null, rs.getString("version"));

				vuln = new Vulnerability(rs.getInt("vuln_id"), rs.getString("cve_id"), rs.getString("description"), rs.getString("platform"), rs.getString("published_date"), rs.getString("last_modified_date"),
						(fixedDate == null ? null : fixedDate.toLocalDateTime()), rs.getBoolean("exists_at_mitre"), rs.getBoolean("exists_at_nvd"), sources, vdoList, cvssScoreList, products);
			}

			return vuln;

		} catch (SQLException e) {
			logger.error(e.getMessage());
		}

		return null;
	}

	public static List<Vulnerability> getVulnerabilityByMatch(String match) {
		try (Connection conn = DBConnect.getConnection()) {
			List<Vulnerability> vulns = new ArrayList<Vulnerability>();
			PreparedStatement stmt = conn.prepareStatement("SELECT v.vuln_id, v.cve_id, v.description, v.platform, v.published_date, v.last_modified " + "FROM Vulnerability v WHERE v.description LIKE ?");
			stmt.setString(1, "%" + match + "%");

			ResultSet rs = stmt.executeQuery();

			while (rs.next()) {
				vulns.add(new Vulnerability(rs.getInt("vuln_id"), rs.getString("cve_id"), rs.getString("description"), rs.getString("platform"), rs.getString("published_date"), rs.getString("last_modified")));
			}

			return vulns;
		} catch (SQLException e) {
			logger.error(e.getMessage());
		}

		return null;
	}

	/**
	 * Retrieves the vulnerabilities that have been updated within a given number of
	 * days from the current date.
	 * 
	 * @param dateRange Number of days before the current date that vulnerabilities
	 *                  will be gathered from
	 * @return Map of vulnerabilities mapped by the date associated with the when
	 *         the vulnerability was updated and the list of vulnerabilities that
	 *         were updated at that date
	 */
	public static Map<LocalDate, List<Vulnerability>> getDailyVulnerabilities(int dateRange) {

		String query = "select * from vulnerabilityaggregate WHERE run_date_time BETWEEN ? AND ?;";
		try (Connection conn = DBConnect.getConnection(); PreparedStatement stmt = conn.prepareStatement(query);) {
			// Get the CVEs for the last 3 days from 2 days ago to today (inclusive)
			LocalDateTime today = LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT).plusDays(1);

			stmt.setTimestamp(1, Timestamp.valueOf(today.minusDays(dateRange)));
			stmt.setTimestamp(2, Timestamp.valueOf(today));

			Timestamp fixedDate = null;
			String[] sources = {};
			VdoCharacteristic[] vdoList = {};
			CvssScore[] cvssScoreList = null;
			Map<LocalDate, List<Vulnerability>> dailyVulns = new LinkedHashMap<>();
			Product product = null;
			Product[] products= null;

			// Populate the dailyVulns map with an empty list of vulns for each day of the
			// search
			for (int days = dateRange; days > 0; days--)
				dailyVulns.put(today.minusDays(days).toLocalDate(), new ArrayList<>());

			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				try {
					if (dailyVulns.get(rs.getTimestamp("run_date_time").toLocalDateTime().toLocalDate()) == null)
						continue;

					fixedDate = rs.getTimestamp("fixed_date");
					vdoList = VulnerabilityUtil.parseVDOList(rs.getString("cve_id"), rs.getString("vdo_labels"), rs.getString("vdo_label_confidences"), rs.getString("vdo_noun_groups"), ";", null);
					cvssScoreList = VulnerabilityUtil.parseCvssScoreList(rs.getString("cve_id"), rs.getString("base_severities"), rs.getString("severity_confidences"), rs.getString("impact_scores"), rs.getString("impact_confidences"), ";",
							null);
					
					products = VulnerabilityUtil.parseProductList(rs.getString("product_id"), rs.getString("cpe"), rs.getString("domain"), rs.getString("version"), ";", null);
					//product = new Product(rs.getInt("product_id"), rs.getString("cpe"), rs.getString("domain"), null, rs.getString("version"));

					dailyVulns.get(rs.getTimestamp("run_date_time").toLocalDateTime().toLocalDate())
							.add(new Vulnerability(rs.getInt("vuln_id"), rs.getString("cve_id"), rs.getString("description"), rs.getString("platform"), rs.getString("published_date"), rs.getString("last_modified_date"),
									(fixedDate == null ? null : fixedDate.toLocalDateTime()), rs.getBoolean("exists_at_mitre"), rs.getBoolean("exists_at_nvd"), sources, vdoList, cvssScoreList, products));
				} catch (Exception e) {
					logger.error(e.getMessage());
				}
			}
			return dailyVulns;
		} catch (SQLException e) {
			logger.error(e.getMessage());
		}

		return null;
	}

	public static void main(String[] args) {

	}
}