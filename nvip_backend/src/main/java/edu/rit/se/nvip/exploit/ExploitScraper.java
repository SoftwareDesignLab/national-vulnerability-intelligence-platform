package edu.rit.se.nvip.exploit;

import edu.rit.se.nvip.crawler.htmlparser.AbstractCveParser;
import edu.rit.se.nvip.model.Exploit;
import edu.rit.se.nvip.utils.GitController;
import edu.rit.se.nvip.utils.MyProperties;
import edu.rit.se.nvip.utils.PropertyLoader;
import edu.rit.se.nvip.utils.UtilHelper;
import edu.stanford.nlp.util.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;

import java.io.*;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ExploitScraper implements Serializable {
	/*
	 * singleton object
	 */
	static ExploitScraper loader;

	private static MyProperties propertiesNvip;

	private static final Logger logger = LogManager.getLogger(ExploitScraper.class);

	// the root nvip data path
	private static String nvipDataPath = "NVIPDataV2";

	// nvip exploit repo path
	private static final String nvipExploitRepoDir = "exploit-repo";

	/**
	 * maps CVE-IDs to the Exploits
	 */
	private final Map<String, List<Exploit>> mapCveIdToExploit;

	/**
	 * map Exploit DB IDs to CVE-IDs to keep track of which exploit DB IDs are already mapped to CVEs.
	 * We will not scrape ExploitDB pages for those Exploit DB IDs!
	 */
	private final Map<Integer, List<String>> mapExploitDbIdToCveId;

	protected final String regexCVEID = "CVE-[0-9]+-[0-9]+";

	public synchronized static ExploitScraper getInstance() {
		MyProperties properties = new MyProperties();
		properties = new PropertyLoader().loadConfigFile(propertiesNvip);

		propertiesNvip = properties;
		nvipDataPath = propertiesNvip.getDataDir();
		logger.info("Using NVIPDataPath: " + nvipDataPath);

		if (loader == null) {
			Path path = Paths.get(propertiesNvip.getDataDir(), "edbid.bin");
			String filename = path.toAbsolutePath().toString();
			loader = ExploitScraper.loadFromFile(filename);

			if (loader == null)
				loader = new ExploitScraper();
			else {
				loader.updateGitRepo();
				loader.fillCVEtoIdMap();
			}
			loader.serializeMeToFile(filename);

		}
		return loader;
	}

	/**
	 * Private constructor this is only used if there is no serializable object, should not happen but
	 * it is a failsafe
	 */
	private ExploitScraper() {
		// update local repo
		updateGitRepo();

		this.mapCveIdToExploit = new HashMap<>();
		this.mapExploitDbIdToCveId = new HashMap<>();
		fillCVEtoIdMap();
	}

	/**
	 * Get list of Exploit script paths from CVE-ID. You need to go to the directory <nvipDataPath> +
	 * "/<nvipExploitRepoDir>/<exploitDbRepoDir>/" to find each exploit script.
	 * <p>
	 * Ee: CVE-2020-1234 --> [exploits/windows/dos/13.c,exploits/windows/dos/17.pl]
	 * 
	 * @param cveId CVEID CVE-XXXX-XXXX
	 * @return A list of exploits!
	 */
	public List<Exploit> getExploits(String cveId) {
		if (mapCveIdToExploit.containsKey(cveId)) {
			return mapCveIdToExploit.get(cveId);
		}
		return new ArrayList<>();
	}

	/**
	 * checks file for serialized version of this class and loads it in to prevent visiting each exploit
	 * db url every time the class is loaded
	 * 
	 * @param filename name of serialized file, should be "edbid.bin" inside the data dir
	 * @return deserialized EDBIDLoader
	 */
	private static ExploitScraper loadFromFile(String filename) {
		ExploitScraper loader;
		try {
			// Reading the object from a file
			FileInputStream file = new FileInputStream(filename);
			ObjectInputStream in = new ObjectInputStream(file);

			// Method for deserialization of object
			loader = (ExploitScraper) in.readObject();

			in.close();
			file.close();
		} catch (IOException | ClassNotFoundException ex) {
			return null;
		}

		return loader;
	}

	/**
	 * serialized this object into binary file
	 * 
	 * @param filename name of file to save to, should be "edbid.bin"
	 */
	private void serializeMeToFile(String filename) {

		try {
			// Saving of object in a file
			FileOutputStream file = new FileOutputStream(filename);
			ObjectOutputStream out = new ObjectOutputStream(file);

			// Method for serialization of object
			out.writeObject(this);

			out.close();
			file.close();
		} catch (IOException ex) {
			logger.error("IOException is caught whilr serializing object to " + filename + "! Details:" + ex);
		}
	}

	/**
	 * pull/clone git repo at https://gitlab.com/exploit-database/exploitdb
	 */
	private void updateGitRepo() {
		// nvip exploit repo for Exploit DB
		String exploitDbRepoDir = "exploitdb";
		Path gitFolder = Paths.get(nvipDataPath, nvipExploitRepoDir, exploitDbRepoDir);
		// we get exploits from this remote repo
		String remotePath = "https://gitlab.com/exploit-database/exploitdb";
		GitController gitController = new GitController(gitFolder.toString(), remotePath);

		File f = new File(gitFolder.toString());
		boolean pullDir = false;

		if (!f.exists())
			f.mkdirs();

		try {
			pullDir = f.exists() && f.list().length > 1;
		} catch (Exception ignored) {
		}

		if (pullDir) {
			if (gitController.pullRepo())
				logger.info("Pulled git repo at: " + remotePath + " to: " + gitFolder);
			else
				logger.error("Failed to pull git repo at: " + remotePath + " to: " + gitFolder);
		} else {
			if (gitController.cloneRepo())
				logger.info("Cloned git repo at: " + remotePath + " to: " + gitFolder);
			else
				logger.error("Could not clone git repo at: " + remotePath + " to: " + gitFolder);

		}
	}

	/**
	 * Takes ExploitDb IDs found inside of files_exploits.cvs and uses that to find the associated CVE
	 * IDs and fills up hash maps that keep track of ExploitDB ID--> CVE-ID and CVE-ID--> Exploit Path
	 * mappings.
	 * 
	 * Ex File Header: id,file,description,date,author,type,platform,port
	 * 
	 * Ex Row: 9,exploits/windows/dos/9.c,"Apache 2.x Memory Leak",2003-04-09,"NA",dos,windows,
	 */
	private void fillCVEtoIdMap() {
		MyProperties propertiesNvip = new MyProperties();
		propertiesNvip = new PropertyLoader().loadConfigFile(propertiesNvip);

		String exploitFile = propertiesNvip.getDataDir() + "/" + nvipExploitRepoDir + "/exploitdb/files_exploits.csv";

		List<String> listLinesInTheFile = new ArrayList<>();

		try {
			Scanner scanner = new Scanner(new File(exploitFile));
			String[] line = scanner.nextLine().split(","); // get rid of header line
			while (scanner.hasNext()) {
				listLinesInTheFile.add(scanner.nextLine());
			}
		} catch (Exception e) {
			logger.error("Failed to open file: " + exploitFile + ", please check if it exists!");
		}

		String[] exploitAttribsFromFile; // get rid of label line
		logger.info("Scraping " + listLinesInTheFile.size() + " websites to find exploits!... It may take some time, please wait!");
		for (int i = 0; i < listLinesInTheFile.size(); i++) {

			String strLine = listLinesInTheFile.get(i);

			exploitAttribsFromFile = strLine.split(",");
			String strExploitDbId = exploitAttribsFromFile[0];
			String strExploitScriptPath = exploitAttribsFromFile[1];

			// avoid any parsing errors with special characters being interpreted as newlines
			if (!StringUtils.isNumeric(strExploitDbId))
				continue;

			int idExploitDb = Integer.parseInt(strExploitDbId);

			// skip over urls that we already have the id in the map
			if (mapExploitDbIdToCveId.containsKey(idExploitDb))
				continue;

			// we will look if there are any CVEs for this Exploit DB ID, init map entry
			mapExploitDbIdToCveId.put(idExploitDb, new ArrayList<>());

			if (i % 1000 == 0) {
				Path savePath = Paths.get(propertiesNvip.getDataDir(), "edbid.bin");
				String saveFilename = savePath.toAbsolutePath().toString();
				serializeMeToFile(saveFilename);
				logger.info("Serialized current state of object to " + saveFilename + ". Scraped " + (i + 1) + " exploits so far!");
			}

			/**
			 * check related Exploit DB page to see if there are any CVEs that are related to this exploit!
			 */
			String publisherUrl = "https://www.exploit-db.com/exploits/" + strExploitDbId;

			// short delay to hopefully avoid being locked out
			try {
				Thread.sleep(50);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			try {
				Connection conn = Jsoup.connect(publisherUrl);
				Document doc = conn.get();
				String text = doc.html();
				Set<String> cveIdSet = getAllCves(text); // get all CVE-IDs from page

				// add the path of exploit code script to the CVE-ID --> Path map
				for (String cveId : cveIdSet) {

					/**
					 * Collect exploit attributes, file header: id,file,description,date,author,type,platform,port
					 * 
					 * Ex:9,exploits/windows/dos/9.c,"Memory Leak",2003-04-09,"Matthew",dos,windows,
					 */
					String now = UtilHelper.longDateFormat.format(new Date()); // current datetime

					// published date
					Date dt = UtilHelper.kbCertDateFormat.parse(exploitAttribsFromFile[3]);
					String sPublishDate = UtilHelper.longDateFormat.format(dt);

					// generate description
					String sDescription = "Description: " + exploitAttribsFromFile[2] + "\tAuthor: " + exploitAttribsFromFile[4] + "\tType: " + exploitAttribsFromFile[5]
							+ "\tPlatform: " + exploitAttribsFromFile[6];
					Exploit exploit = new Exploit(cveId, idExploitDb, sPublishDate, publisherUrl, sDescription, strExploitScriptPath, now);

					if (mapCveIdToExploit.containsKey(cveId)) {
						if (!mapCveIdToExploit.get(cveId).contains(strExploitScriptPath)) {
							mapCveIdToExploit.get(cveId).add(exploit);
						}
					} else {
						mapCveIdToExploit.put(cveId, new ArrayList<>());
						mapCveIdToExploit.get(cveId).add(exploit);
					}
					mapExploitDbIdToCveId.get(idExploitDb).add(cveId); // record Exploit DB--> CVE-ID mapping
				}
				Thread.sleep(100);
			} catch (Exception e) {
				logger.error("Failed to visit: " + publisherUrl + "Exception: " + e);
			}

		}

		logger.info("Done! Generated " + mapCveIdToExploit.size() + " CVE--> Exploit mappings!");
	}

	/**
	 * gets all CVEs based on regex from given html fillCVEtoIdMap visits site and gets html
	 * 
	 * @param html string of html content
	 * @return set of CVE IDs
	 */
	private Set<String> getAllCves(String html) {
		Pattern pattern = Pattern.compile(regexCVEID);
		Matcher matcher = pattern.matcher(html);
		Set<String> cves = new HashSet<>();
		while (matcher.find())
			cves.add(matcher.group());

		return cves;
	}

	public int getNumberOfExploits() {
		return this.mapExploitDbIdToCveId.size();
	}

}
