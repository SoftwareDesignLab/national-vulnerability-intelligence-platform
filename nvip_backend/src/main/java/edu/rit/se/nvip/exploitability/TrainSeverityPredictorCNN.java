/**
 * Copyright 2021 Rochester Institute of Technology (RIT). Developed with
 * government support under contract 70RSAT19CB0000020 awarded by the United
 * States Department of Homeland Security.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package edu.rit.se.nvip.exploitability;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.deeplearning4j.iterator.CnnSentenceDataSetIterator;
import org.deeplearning4j.models.embeddings.loader.WordVectorSerializer;
import org.deeplearning4j.models.embeddings.wordvectors.WordVectors;
import org.deeplearning4j.nn.api.Layer;
import org.deeplearning4j.nn.graph.ComputationGraph;
import org.deeplearning4j.optimize.listeners.ScoreIterationListener;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.dataset.api.iterator.DataSetIterator;

import edu.rit.se.nvip.cvss.utils.CompGraphDataUtils;
import edu.rit.se.nvip.cvss.utils.ModelParams;
import edu.rit.se.nvip.utils.MyProperties;
import edu.rit.se.nvip.utils.PropertyLoader;
import edu.rit.se.nvip.utils.UtilHelper;

/**
 * 
 * This class was used to train models for NVIP. It trains and serializes three
 * models to predict:
 * 
 * 1. CVE Severity
 * 
 * 2. CVE Impact
 * 
 * @author axoeec
 *
 */
public class TrainSeverityPredictorCNN {
	private Logger logger = LogManager.getLogger(getClass().getSimpleName());

	/**
	 * Location (local file system) for the Google News vectors. Set this manually.
	 */
	public static String WORD_VECTORS_PATH = null;
	private static String basePath = null;
	private CompGraphDataUtils utils = new CompGraphDataUtils();

	public static void main(String[] args) throws Exception {

		MyProperties proeperties = new MyProperties();
		proeperties = new PropertyLoader().loadConfigFile(proeperties);
		basePath = proeperties.getDataDir() + "/characterization/cvss";
		WORD_VECTORS_PATH = basePath + "/" + ModelParams.getWordvectorfile();
		// WORD_VECTORS_PATH = basePath + "/CveWord2vec.gz";

		TrainSeverityPredictorCNN cnnSentenceClassification = new TrainSeverityPredictorCNN();

		// generate data and train a model for CVE Severity
		cnnSentenceClassification.trainSeverityModel(cnnSentenceClassification, "severity", "dl-severity.model");

		// generate data and train model for CVE Impact
		cnnSentenceClassification.trainImpactModel(cnnSentenceClassification, "impact", "dl-impact.model");

	}

	private void trainImpactModel(TrainSeverityPredictorCNN cnnSentenceClassification, String trainingDataFileNameWithoutExtension, String modelFileName) {
		String arffDataPath = basePath + "/" + trainingDataFileNameWithoutExtension + ".arff";
		logger.info("Preparing data for DataSetIterator using " + arffDataPath + " ...");
		utils.prepareData(basePath, arffDataPath);
		String dlDataPath = basePath + "/" + trainingDataFileNameWithoutExtension;
		List<String> labels = new ArrayList<String>();
		for (int i = 1; i <= 10; i++)
			labels.add(String.valueOf(i));
		labels.remove("2");
		String modelName = basePath + "/" + modelFileName;
		logger.info("Traininig a MULTI-CLASS Impact predictor for CVEs, Training Data: " + arffDataPath + ", Trained model will be at: " + modelName);

		cnnSentenceClassification.trainDLModel(labels, dlDataPath, modelName, true);
	}

	private void trainSeverityModel(TrainSeverityPredictorCNN cnnSentenceClassification, String trainingDataFileNameWithoutExtension, String modelFileName) {
		String arffDataPath = basePath + "/" + trainingDataFileNameWithoutExtension + ".arff";
		logger.info("Preparing data on for the DataSetIterator using " + arffDataPath + " ...");
		utils.prepareData(basePath, arffDataPath);

		String dlDataPath = basePath + "/" + trainingDataFileNameWithoutExtension;
		List<String> labels = new ArrayList<String>();
		labels.add("1");
		labels.add("4");
		labels.add("7");
		labels.add("10");
		String modelName = basePath + "/" + modelFileName;

		logger.info("Traininig a MULTI-CLASS Severity predictor for CVEs, Training Data: " + arffDataPath + ", Trained model will be at: " + modelName);
		cnnSentenceClassification.trainDLModel(labels, dlDataPath, modelName, true);
	}

	/**
	 * train a model and serialize it.
	 * 
	 * @param multiclass  TODO
	 * 
	 * @param dataLabels: The labels of the data
	 * @param dataPath:   The physical path of the data
	 * @param modelName:  The name of the model for serialization
	 */
	private void trainDLModel(List<String> dataLabels, String dataPath, String modelName, boolean multiclass) {

		// init net
		ComputationGraph net = utils.initDLCNNNet(dataLabels, multiclass);

		logger.info("Number of parameters by layer:");
		for (Layer l : net.getLayers()) {
			logger.info("\t" + l.conf().getLayer().getLayerName() + "\t" + l.numParams());
		}

		// Load word vectors and get the DataSetIterators for training and testing
		logger.info("Loading word vectors and creating DataSetIterators");
		WordVectors wordVectors = WordVectorSerializer.loadStaticModel(new File(WORD_VECTORS_PATH));
		DataSetIterator trainingData = utils.getDataSetIterator(dataLabels, dataPath, wordVectors, ModelParams.getBatchsize(), ModelParams.getTruncatedocumentstolength(), ModelParams.getRandomnumbergenerator());

		logger.info("Start training DL model");
		net.setListeners(new ScoreIterationListener(ModelParams.getPrintscoreperitems())); // output score per 100 items
		net.fit(trainingData);

		logger.info("Training done! Saving model to " + modelName);
		try {
			net.save(new File(modelName)); // save model
		} catch (IOException e) {
			e.printStackTrace();
			logger.error(e.toString());
		}

		// After training: load a single sentence and generate an example prediction
		String testSentence = "radexecd.exe in Persistent Systems Radia Client Automation (RCA) 7.9, 8.1, 9.0, and 9.1 allows remote attackers to execute arbitrary commands via a crafted request to TCP port 3465.\r\n" + "\r\n"
				+ "The software constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.\r\n"
				+ "\r\n"
				+ "When software allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the software. Such an alteration could lead to arbitrary code execution.\r\n"
				+ "Injection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.\r\n"
				+ "\r\n" + "";
		INDArray featuresTestSentence = ((CnnSentenceDataSetIterator) trainingData).loadSingleSentence(testSentence);

		INDArray predictions = net.outputSingle(featuresTestSentence);
		List<String> labels = trainingData.getLabels();

		System.out.println("\n\nPredictions for the test sentence:");
		for (int i = 0; i < labels.size(); i++) {
			System.out.println("P(" + labels.get(i) + ") = " + predictions.getDouble(i));
		}
	}

}
