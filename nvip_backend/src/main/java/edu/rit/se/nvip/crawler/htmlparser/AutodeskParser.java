package edu.rit.se.nvip.crawler.htmlparser;

import com.google.common.collect.Iterables;
import edu.rit.se.nvip.model.AffectedRelease;
import edu.rit.se.nvip.model.CompositeVulnerability;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class AutodeskParser extends AbstractCveParser {

    public AutodeskParser(String domainName) {sourceDomainName = domainName;}
    @Override
    public List<CompositeVulnerability> parseWebPage(String sSourceURL, String sCVEContentHTML) {
        List<CompositeVulnerability> retVal = new ArrayList<>();

        Document doc = Jsoup.parse(sCVEContentHTML);
        // get publish/revision dates from the summary info near the top
        Element pSummary = doc.select("p:contains(Original Publish)").last();
        String[] pText = pSummary.html().split("<br>");
        String pubDate = parseDateFromRow(pText[4]);
        String revDate = parseDateFromRow(pText[5]);

        // pull out info from summary/description fields. Some pages have essentially no information in the
        // description section so use the summary in that case.
        Elements h3s = doc.select("h3");
        String summary = "";
        for (Element h3 : h3s) {
            if (h3.text().equals("Summary")) {
                summary = h3.nextElementSibling().text();
            }
            if (h3.text().equals("Description")) {
                Element descriptionParent = h3.nextElementSibling().nextElementSibling();
                // in this case the page just lists CVEs and the libraries they impact
                if (descriptionParent.tagName().equals("table")) {
                    Elements rows = descriptionParent.getElementsByTag("tr");
                    String leftLabel = rows.get(0).children().get(0).text();
                    for (int i = 1; i < rows.size(); i++) {
                        for (String cve : getCVEs(rows.get(i).html())) {
                            String des = String.format("%s\n%s: %s", summary, leftLabel, rows.get(i).children().get(0).text());
                            retVal.add(new CompositeVulnerability(
                                   0,
                                   sSourceURL,
                                   cve,
                                   "autodesk",
                                   revDate,
                                   pubDate,
                                   des,
                                   sourceDomainName
                            ));
                        }
                    }
                }
                // in this case the vulnerabilities are listed with a distinct description for each
                else if (descriptionParent.tagName().equals("ol")) {
                    for (Element li : descriptionParent.children()) {
                        int desStart = li.text().indexOf(":") + 2;
                        retVal.add(new CompositeVulnerability(
                                0,
                                sSourceURL,
                                Iterables.getOnlyElement(getCVEs(li.text())),
                                "autodesk",
                                revDate,
                                pubDate,
                                li.text().substring(desStart),
                                sourceDomainName
                        ));
                    }
                }
            }
        }
        return retVal;
    }

    private String parseDateFromRow(String row) {
        String out = "";
        Matcher matcher = Pattern.compile(regexDateFormatNumeric).matcher(row);
        SimpleDateFormat sdf_in = new SimpleDateFormat("MM/dd/yyyy");
        SimpleDateFormat sdf_out = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        try {
            if (matcher.find()) {
                out = sdf_out.format(sdf_in.parse(matcher.group()));
            }
        } catch (ParseException e) {
            out = "";
        }
        return out;
    }
}
